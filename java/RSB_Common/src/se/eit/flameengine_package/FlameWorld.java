package se.eit.flameengine_package;

import java.util.Random;


import se.eit.d1_pkg.D1Container;
import se.eit.d1_pkg.D1IdObj;
import se.eit.d1_pkg.D1SubRoot;
import se.eit.d1_pkg.D1ThreadSafe;
import se.eit.rsb_package.GameUser;
import se.eit.rsb_package.UserAccount;
import se.eit.rsb_package.RoundBuffer;
import se.eit.rsb_package.WorldWithPlayers;
import se.eit.web_package.WordReader;
import se.eit.web_package.WordWriter;

public class FlameWorld extends WorldWithPlayers {

	
	long tickTimeMs=0;

	RoundBuffer roundBuffer=new RoundBuffer(32);
	
	public static String className()
	{	
		// http://stackoverflow.com/questions/936684/getting-the-class-name-from-a-static-method-in-java		
		return FlameWorld.class.getSimpleName();	
	}
	
	/*
	public FlameWorld(D1Container parent, String name, String createdBy) 
	{
		super();
		
		regName(name);
		setCreatedBy(createdBy);
	}
	*/
	
	public FlameWorld()
	{
		super();
	}

	@Override
	public void generateSelf()
	{
		// Nothing done here, world is generated by call to generateSelf(int size) later.
	}
	
	public void generateSelf(int size)
	{
		
		debug("Creating new world " + getNameAndPath("/"));
		
		// Here we create the spawnRoom...
		FlameRoom spawnRoom = new FlameRoom(this, "spawnRoom", size);

		// For random cactuses
		Random cactusR = new Random ();
		for (int i = 2; i < spawnRoom.ySectors; i = i + 4)
		{
			for (int j = 2; j < spawnRoom.xSectors; j = j + 4)
			{
				if (cactusR.nextInt(10) == 1)
					spawnRoom.changeTile(j, i, FlameTile.cactus);

			}
		}
				
		
		MazeGenerator maze = new MazeGenerator (spawnRoom.xSectors / 4, spawnRoom.ySectors / 4);
		maze.insertMaze(spawnRoom);
		
		// For tanker strike
		HmegFlag blueFlag = new HmegFlag();
		blueFlag.linkSelf(spawnRoom);
		blueFlag.teamIndex=1;
		blueFlag.position = FlamePao.getRandomPos(spawnRoom);
		blueFlag.entitySprite = 15;
		blueFlag.state = 1;
		this.setUpdateCounter();
		
		HmegFlag redFlag = new HmegFlag();
		redFlag.linkSelf(spawnRoom);
		redFlag.teamIndex=2;
		redFlag.position = FlamePao.getRandomPos(spawnRoom);
		redFlag.entitySprite = 15;
		redFlag.state = 0;
		this.setUpdateCounter();
		
	}
	
	@Override
	public void setTeam(GameUser apr, int team)
	{
		apr.teamIndex = team;
	}
	
	// This returns the name of the server object that clients shall use to play this world.
	public String serverForThisWorld()
	{
		return "FlameServer"; // The name used needs to match that in serverFactory
	}

	@Override
	public void linkSelf(D1Container parentObj)
	{
		super.linkSelf(parentObj);
		
		// THe tick we want. (Higher the better)
		requestTick(100);
	}
	
	@Override
	public void readSelf(WordReader wr)	
	{
		super.readSelf(wr);
		// It seems we should check that database is locked here. It is not always...		
	}

	// serialize to ww
	@Override
	public void writeSelf(WordWriter ww)
	{		
		super.writeSelf(ww);
		
	}
	
	// For the chat!
	public void messageFromPlayer(UserAccount player, String msg)
	{		
		//stringFifo.put(msg);
		debug("messageFromPlayer "+player.getName()+" "+msg);
		
		roundBuffer.put(player.getName()+": "+msg);
        notifySubscribers(this.getId());
		
	}

	// To get messages!
	public String getMsg(int updateCounter)
	{		
		return roundBuffer.get(updateCounter);
	}
	
	protected GameUser playerJoinedCreateApr(UserAccount player, int team)
	{
		final String playerName=player.getName();
		FlameUser apr = (FlameUser)listOfUsers.findOrCreateChildObject(playerName, "FlameUser"); 
		apr.player=player;
		apr.setTeam(team);
	
		playerJoinedFindOrCreateAvatar(apr); 
		
		return apr;
	}
	
	public FlameUser playerConnected(UserAccount player, int team)
	{
		getListOfActivePlayers();
		
		final String playerName=player.getName();
		
		// First check that player is not already playing here
		FlameUser apr = (FlameUser)listOfUsers.findObjectByNameAndType(playerName, "AvatarPlayerReferences");

		D1SubRoot ro = this.getDbSubRoot();
		ro.lockWrite();
		try
		{

			if (apr!=null)			
			{
				if (apr.getActive()==false)
				{
					// This is a returning player, the player can now start playing
					
					playerJoinedFindOrCreateAvatar(apr);				
					apr.setTeam(0); // Temporary fix to force setTeam on next line to update things
					apr.setTeam(team);
					apr.setActive(true);
					apr.setUpdateCounter();

				}
				else
				{
					// This player is already playing in at this world, can not connect one more.
					return null;
				}
			}
			else
			{
				// This is a new player, create a new avatar.
				apr = (FlameUser) playerJoinedCreateApr(player, team);		
				
				setTeam(apr, team);
			}
		}
		finally
		{
			ro.unlockWrite();
		}
		
		
		return apr;
	}
	
	@Override
	public D1ThreadSafe findSpawnRoom(GameUser gameUser)
	{
		return (D1ThreadSafe)this.findDbNamedRecursive("spawnRoom", 5);	
	}
	
	// This is called from base class WorldWithPlayers when a player has joined.
	//@Override
	public FlameAvatar playerJoinedFindOrCreateAvatar(GameUser gameUser)

	{
		debugWriteLock();
		FlameAvatar avatar=null;
		
		// Does the player already have an avatar?
		if (gameUser.avatarId==-1)
		{			
			
			// Find spawn room and create an avatar for the player. 
			FlameRoom spawnRoom = (FlameRoom)findSpawnRoom(gameUser);	
			
			if (spawnRoom==null)
			{
				// this can happen if a player press cancel at the wrong moment while connection.
				debug("did not find spawn room");
				return null;
			}
			else
			{
			    	
		    	// No LUA override to create the avatar
		    	avatar = new FlameAvatar();
			    avatar.linkSelf(spawnRoom);
			    avatar.regName(gameUser.getName());
			    
			    avatar.setAvatarPlayerReferences(gameUser);
			    gameUser.avatarId = avatar.getId();
			    gameUser.setActive(true); // Remember to call playerDisconnected when leaving so that active can be set to false.

			}
		}
		else
		{
			
			// The player already has an avatar.
			avatar = (FlameAvatar)this.getDbSubRoot().getDbIdObj(gameUser.avatarId);
			if (avatar==null)
			{
				error("did not find avatar ~"+gameUser.avatarId);			
			}
		}
		
		
	    avatar.postMessageToThis("welcome player "+gameUser.getName()+", to the world "+this.getName());

	    gameUser.getParent().postMessageToThis("player "+gameUser.getName()+" joined team "+gameUser.teamIndex);
	    
		return avatar;
	}

	// Does final make it un-overridable.
	@Override
	final public void tickMsCallback(long tickTimeMs)
	{
		final long deltaTimeMs = tickTimeMs - this.tickTimeMs;
		this.tickTimeMs += deltaTimeMs;

		if (notificationDataList.size()!=0)
		{
			try
			{
				this.lockWrite();
				// TODO: Here we do tick on all objects in this game regardless if those need it or not. We could use CPU more efficiently...
				for (D1IdObj dio : idList.dbListId)
				{
					if (dio instanceof FlameEntity)
					{
						FlameEntity cpe = (FlameEntity)dio;
						cpe.tickEntityMs(deltaTimeMs);
					}
				}
			}
			finally
			{
				this.unlockWrite();
			}
		}
	}
}
